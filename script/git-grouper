#!perl

use 5.010001;
use strict;
use warnings;

use Perinci::CmdLine::Any;

# AUTHORITY
# DATE
# DIST
# VERSION

Perinci::CmdLine::Any->new(
    url => '/Git/Grouper/',
    subcommands => {
        "ls-all-groups" => { url => '/Git/Grouper/ls_all_groups' },
        "ls-all-remotes" => { url => '/Git/Grouper/ls_all_remotes' },

        "ls-repo-groups" => { url => '/Git/Grouper/ls_repo_groups' },
        "ls-repo-remotes" => { url => '/Git/Grouper/ls_repo_remotes' },

        "filter-repo-has-group" => { url => '/Git/Grouper/filter_repo_has_group' },
        "filter-repo-lacks-group" => { url => '/Git/Grouper/filter_repo_lacks_group' },
        "filter-repo-orphan" => { url => '/Git/Grouper/filter_repo_orphan' },
        "filter-repo-not-orphan" => { url => '/Git/Grouper/filter_repo_not_orphan' },
        "filter-repo-multiple-group" => { url => '/Git/Grouper/filter_repo_multiple_group' },
        "filter-repo-single-group" => { url => '/Git/Grouper/filter_repo_single_group' },

        "configure-repo" => { url => '/Git/Grouper/configure_repo' },
    },
    #default_subcommand => 'get-repo-group',
    read_env => 0,
    read_config => 0,
    log => 1,
)->run;

1;
# ABSTRACT:
# PODNAME:

=head1 SYNOPSIS

=head2 Listing groups

List all defined groups:

 % git-grouper ls-all-groups      ; # just list the names
 % git-grouper ls-all-groups -l   ; # list detailed records

List which group(s) repositories belong to:

 % git-grouper ls-repo-groups ; # list current working repo's group(s)
 % git-grouper ls-repo-groups REPO1 REPO2 ...
 % git-grouper ls-repo-groups REPO1 REPO2 ...

=head2 Listing repositories

List repositories that belong to specified group(s):

 % git-grouper filter-repo-has-group GROUP REPO1 REPO2 ...
 % git-grouper filter-repo-has-group --ignore-nondirs *
 % git-grouper filter-repo-has-group 'GROUP1&GROUP2' REPO1 REPO2 ... ; # repos must belong to all of specified groups
 % git-grouper filter-repo-has-group 'GROUP1|GROUP2' REPO1 REPO2 ... ; # repos must belong to any of specified groups

List repositories that do not belong to specified group(s):

 % git-grouper filter-repo-lacks-group GROUP REPO1 REPO2 ...
 % git-grouper filter-repo-lacks-group --ignore-nondirs *
 % git-grouper filter-repo-lacks-group 'GROUP1&GROUP2' REPO1 REPO2 ... ; # repos must not belong to any of specified groups
 % git-grouper filter-repo-lacks-group 'GROUP1|GROUP2' REPO1 REPO2 ... ; # repos must not belong to just one of specified groups

List repositories that do not belong to any group:

 % git-grouper filter-repo-orphan REPO1 REPO2 ...
 % git-grouper filter-repo-orphan --ignore-nondirs *

List repositories that belong to a group or more:

 % git-grouper filter-repo-not-orphan REPO1 REPO2 ...
 % git-grouper filter-repo-not-orphan --ignore-nondirs *

List repositories that belong to multiple (instead of a single) group:

 % git-grouper filter-repo-multiple-group REPO1 REPO2 ...
 % git-grouper filter-repo-multiple-group --ignore-nondirs *

List repositories that belong to just one (instead of multiple) group:

 % git-grouper filter-repo-single-group REPO1 REPO2 ...
 % git-grouper filter-repo-single-group --ignore-nondirs *

=head2 Listing repositories

List all defined repositories:

 % git-grouper ls-all-remotes      ; # just list the names
 % git-grouper ls-all-remotes -l   ; # list detailed records

List repo's remotes according to group's configuration:

 % git-grouper ls-repo-remotes ; # remotes of current working repo
 % git-grouper ls-repo-remotes REPO1 REPO2 ...
 % git-grouper ls-repo-remotes --ignore-nondirs *

=head2 Configuring repositories based on group's attributes

 % git-grouper configure-repo ; # configure current working repo
 % git-grouper configure-repo REPO1 REPO2 ...
 % git-grouper configure-repo --ignore-nondirs *


=head1 DESCRIPTION

B<git-grouper> is a tool to categorize your git repository into one of
predefined groups. Later, you can: 1) set your repository's remotes, username,
email, etc based on the group's attributes; 2) perform actions on a group of
repositories.

Why group git repositories? To perform actions on a set of git repositories in
one go. Also, another reason is to set remotes or username/email based on a
group's characteristics instead of individually. One case where this can be
useful is when restoring repositories from backup via cloning. You might want to
clone from local backup instead of from origin, but when cloning git will set
origin of your restored repository to your backup. With git-grouper, you can
restore the origin (as well as other remotes) from a configuration.

To use git-grouper, you first create a configuration file in L<IOD> format, e.g.
at I<~/.config/git-grouper.conf>. In it, you define your groups, remotes, nad
other things. Details on the configuration can be read in the L</CONFIGURATION
FILE> section. After that, you can use run this command with one of the
available subcommands (see L</SYNOPSIS>).


=head1 CONFIGURATION FILE

Configuration file is in L<IOD> format, which is based on INI that is familiar
to most. Groups and remotes are written as IOD sections, much like in git
configuration.

=head2 A sample configuration file

 [remote "github"]
 url_template = git@github.com:[% github_username %]/[% repo_name %].git

 [remote "github_company1"]
 url_template = git@github.com+company1:company1/[% repo_name %].git

 [remote "privbak"]
 url_template = ssh://u1@hostname:/path/to/[% repo_name %].git

 [group "company1"]
 repo_name_pattern = /^company1-/
 remotes = ["github_company1", "privbak"]
 username = foo
 email = foo@company1.com

 [group "priv_perl"]
 repo_name_pattern = /^perl-/
 has_tags = ["priv"]
 remotes = ["github", "privbak"]
 username = perlancar
 email = perlancar@gmail.com

 [group "perl"]
 repo_name_pattern = /^perl-/
 github_username = perlancar
 remotes = ["github", "privbak"]
 username = perlancar
 email = perlancar@gmail.com

 [group "other"]
 repo_name_pattern = /^./
 remotes = ["privbak"]
 username = foo
 email = foo@example.com

=head2 Group definition

 [group GROUPNAME]
 ; filter keys
 repo_pattern_name = /REGEX/
 has_all_tags = [TAG1, TAG2, ...]
 has_any_tags = [TAG1, TAG2, ...]
 lacks_all_tags = [TAG1, TAG2, ...]
 lacks_any_tags = [TAG1, TAG2, ...]

 ; attribute keys
 remotes = [REMOTE1, REMOTE2, ...]
 user_name = SOME NAME
 email = EMAIL@ADDRESS

Group name must be an I<identifier>, which means it must start with a letter or
underscore, and contains only alphanumeric characters.

A group definition contains I<filter keys> (keys which specify which
repositories can belong to this group) and I<attribute keys> (keys that set what
attributes repositories in this group should have). To belong to the group,
I<all> filters must be satisfied.

Note that instead of satisfying all filters, you can also make a repository
belong to a group by having an empty file named C<.group-GROUPNAME> in the
top-level directory.

=over

=item * repo_pattern_name

A regex pattern. Repositories that have names that match this pattern will
satisfy this filter.

=item * has_all_tags

An array of strings (tags). Repositories must have all the specified tags to
satisfy this filter. Tags are identifiers. Repository can be tagged by having an
empty file that is named C<.tag-TAGNAME> in the top-level directory.

=item * has_any_tags

An array of strings (tags). Repositories just need to have one of the specified
tags to satisfy this filter.

=item * lacks_all_tags

An array of strings (tags). Repositories must lack all the specified tags to
satisfy this filter.

=item * lacks_any_tags

An array of strings (tags). Repositories just need to lack any the specified
tags to satisfy this filter.

=back


=head1 append:SEE ALSO

L<gitbunch> from L<Git::Bunch>

=cut
